#!/usr/bin/env python
''' Python DB API 2.0 driver compliance unit test suite.  
Only a few 'optional extensions' are being tested at this point.
'''
#TODO: Use assertRaises from ActiveState scripts
#TODO: Make sure all tests have comments.
#TODO: Fix this all the tests that require 'amiracle'. (These tests are skipped).

__rcs_id__  = '$Id$'
__version__ = '$Revision$'[11:-2]
__author__ = 'Ken Kuhlman <acute@redlagoon.net>'
# $Log: dbapi20.py,v $

import unittest
import time
import datetime
import popen2
import config
import util
import decorators
from decorators import requires, raises, supported_features
import features

table_prefix = config.table_prefix
driver_name = config.driver_name
driver_supports = features.SupportedFeatures(driver_name)
decorators.supported_features = driver_supports

driver_module = util.import_module(driver_name)

master_table_list = ['testtypes','booze','barflys']
tables = {}
for table_name in master_table_list:
  tables[table_name] = table_prefix + table_name

ddl1 = 'create table %sbooze (name varchar(20))' % table_prefix
ddl2 = 'create table %sbarflys (name varchar(20))' % table_prefix
#TODO: Was int1 INTEGER NOT NULL GENERATED BY DEFAULT AS IDENTITY,
#TODO: Had to drop not null & primary key def on int1 b/c datatypes tests didn't always use it
#TODO:   Note that pysqlite was still allowing inserts, see "test null violations" note below
#TODO: Had to change CLOB & BLOB to text for postgres
#TODO:  Change to be table per column??
"create table apitest_testtypes (int1 INTEGER, varchar1 VARCHAR(3), date1 date, timestamp1 timestamp,time1 time, clob1 text, blob1 text)"

#TODO: Change to be table per column?  Or just make _insert smarter?
ds = driver_supports
ddl3 = ("""create table %s (
        int_fld %s,
        varchar1 VARCHAR(3),
        date1 date,
        timestamp1 timestamp,
        time1 time,  
        clob1 %s,
        blob1 %s
        )"""
        % ('apitest_testtypes', ds.serial_key_def, ds.clob_type,
              ds.blob_type, ))
#print "DDL3:", ddl3

def create_table(con, cs, statement):
    #print "Create table statement is", statement
    cs.execute(statement)
    if driver_supports.transactional_ddl:
      con.commit()

def drop_table(con, cs, table, ignore_errors=False):
    try:
        cs.execute('drop table %s' % table)
    except:
        if not ignore_errors:
            raise
    if driver_supports.transactional_ddl:
       con.commit()

def setup_once():
    """ Create the tables used in the tests. 
    Also Create the db if needed and create_db_cmd is configured.
    """
    tear_down_once()
    try:
        con = connect()
    except:
        create_db_cmd = config.create_db_cmds[driver_name]
        if create_db_cmd:
            cout,cin = popen2.popen2(create_db_cmd)
            cin.close()
            cout.read()
            con = connect()
        else:
            raise Exception("Can't connect to database and no "
                  "create command given")

    cs = con.cursor() 
    for statement in [ddl1, ddl2, ddl3]:
        create_table(con, cs, statement)
    con.close()
    return

def tear_down_once():
    for table in tables.values():
        con = connect()
        cs = con.cursor()
        try:
            cs.execute("drop table %s" % table)
            con.commit()
        except driver_module.Error:
            pass
    con.close()

def connect(connection_info=None, connection_method='default'):
    if connection_info == None:
        connection_info = config.ConnectionInfo

    args, kwargs = util.convert_connect_args(
           connection_info, driver_name, connection_method)

    try:
        con = driver_module.connect(*args, **kwargs)
    except AttributeError:
        raise("No connect method found in driver module")
    return con

def connect_plus_cursor(connection_info=None, connection_method='default'):
    con = connect(connection_info, connection_method)
    try:
        cs = con.cursor()
    except AttributeError:
        raise("No cursor method found on connection")
    return con, cs


class AcuteBase(unittest.TestCase):
    """ Base class for the tests. Defines basic setup, Teardown, _connect methods. """

    # The name of the driver & the driver itself (as imported)
    driver_name = driver_name
    driver = driver_module

    # Keyword arguments for connect
    #TODO: Change to support URIs instead of this custom class.  
    connection_info = config.ConnectionInfo()
    connection_method = config.connection_method
    create_db_cmd = config.create_db_cmds.get(driver_name, None)

    def _connect(self, *args, **kwarg):
      con = connect(*args, **kwarg)
      self.con = con
      return con

    def _insert(self, con, cur, table=None, data=None, stmt_type='insert'):
        def list_to_sqllist(list):
            elems = len(list)
            res = ''
            for pos, item in enumerate(list):
                res += item
                if pos < elems - 1:
                    res += ', '
            return res

        if not table:
            table = table_prefix + 'booze'
        if not data:
            data = dict(name="Coopers")
        cols = list_to_sqllist(data.keys())

        stmt_base = 'insert into %s (%s) values' % (table, cols)
        if stmt_type == 'select':
            stmt_base = 'select * from %s where %s = ' % (table, data.keys()[0])

        data_keys = data.keys()
        markers = []
        for xx in range(len(data_keys)):
            if self.driver.paramstyle == 'qmark':
                marker = '?'
            elif self.driver.paramstyle == 'numeric':
                marker = '(:%s)' % (xx + 1)
            elif self.driver.paramstyle == 'format':
                marker = '(%s)'
            elif self.driver.paramstyle == 'named':
                marker = '(:%s)'
            elif self.driver.paramstyle == 'pyformat':
                marker = '(%(' + data_keys[xx] + ')s)'

            markers.append(marker)
        stmt = stmt_base + '(' + list_to_sqllist(markers) +')'

        if self.driver.paramstyle in ('qmark', 'numeric', 'format'):
            print "Format is", self.driver.paramstyle
            print "Statement is", stmt
            cur.execute(stmt, data.values())
        elif self.driver.paramstyle in ('named', 'pyformat'):
            cur.execute(stmt, data)
        else:
            self.fail('Invalid paramstyle')        
        con.commit()

class TestModule(AcuteBase):
    """ Test module level attributes """
    def test_connect(self):
        con = self._connect()
        con.close()

    def test_apilevel(self):
        self.failUnless(hasattr(self.driver, "apilevel"), "Driver must define apilevel")
        self.assertEqual(self.driver.apilevel, driver_supports.dbapi_level)

    def test_threadsafety(self):
        self.failUnless(hasattr(self.driver, "threadsafety"), "Driver must define threadsafety")
        self.failUnless(self.driver.threadsafety in (0,1,2,3), "Threadsafety not in allowed values")

    def test_globalparamstyle(self):
        self.failUnless(hasattr(self.driver, "paramstyle"), "Driver must define paramstyle")
        paramstyles = ('qmark','numeric','named','format','pyformat')
        self.failUnless(self.driver.paramstyle in paramstyles, "Paramstyle not in allowed values")  

    def test_Exceptions(self):
        """Required exceptions must be in the defined heirachy."""
        self.failUnless(issubclass(self.driver.Warning,StandardError))
        self.failUnless(issubclass(self.driver.Error,StandardError))
        self.failUnless(
            issubclass(self.driver.InterfaceError,self.driver.Error)
            )
        self.failUnless(
            issubclass(self.driver.DatabaseError,self.driver.Error)
            )
        self.failUnless(
            issubclass(self.driver.OperationalError,self.driver.Error)
            )
        self.failUnless(
            issubclass(self.driver.IntegrityError,self.driver.Error)
            )
        self.failUnless(
            issubclass(self.driver.InternalError,self.driver.Error)
            )
        self.failUnless(
            issubclass(self.driver.ProgrammingError,self.driver.Error)
            )
        self.failUnless(
            issubclass(self.driver.NotSupportedError,self.driver.Error)
            )

#TODO: pyscopg2 fails these because it's returning a string. Move to 'intermediate'?
#TODO:  -- Date(2007, 05, 01).adapted works though
class TestModuleDatatypes(AcuteBase):
    """ Test module level datatypes.  TestTypesEmbedded below tests their use in
    SQL statements.
    """
    driver = driver_module
    
    def test_DateFromTicks(self):
        d = self.driver.DateFromTicks(6798)

    def test_TimeFromTicks(self):
        t = self.driver.TimeFromTicks(6798)

    def test_TimestampFromTicks(self):
        ts = self.driver.TimestampFromTicks(6798)
        
    #TODO: More datatype tests exist in TestTypes. Consolidate?
    def test_Date(self):
        d1 = self.driver.Date(2002,12,25)
        d2 = self.driver.DateFromTicks(time.mktime((2002,12,25,0,0,0,0,0,0)))
        # Can we assume this? API doesn't specify, but it seems implied
        # self.assertEqual(str(d1),str(d2))

    def test_Time(self):
        t1 = self.driver.Time(13,45,30)
        t2 = self.driver.TimeFromTicks(time.mktime((2001,1,1,13,45,30,0,0,0)))
        # Can we assume this? API doesn't specify, but it seems implied
        # self.assertEqual(str(t1),str(t2))

    def test_Timestamp(self):
        t1 = self.driver.Timestamp(2002,12,25,13,45,30)
        t2 = self.driver.TimestampFromTicks(
            time.mktime((2002,12,25,13,45,30,0,0,0))
            )
        # Can we assume this? API doesn't specify, but it seems implied
        # self.assertEqual(str(t1),str(t2))

    @requires('driver_level_datatypes_binary')
    def test_Binary(self):
        b = self.driver.Binary('Something')
        b = self.driver.Binary('')

    @requires('driver_level_datatypes')
    def test_STRING(self):
        'module.STRING must be defined'
        self.driver.STRING

    @requires('driver_level_datatypes')
    def test_BINARY(self):
        'module.BINARY must be defined.'
        self.driver.BINARY
  
    @requires('driver_level_datatypes')
    def test_NUMBER(self):
        'module.NUMBER must be defined.'
        self.driver.NUMBER

    @requires('driver_level_datatypes')
    def test_DATETIME(self):
        'module.DATETIME must be defined.'
        self.driver.DATETIME
  
    @requires('driver_level_datatypes')
    def test_ROWID(self):
        'module.ROWID must be defined.'
        self.driver.ROWID
        
    def test_date(self):
        print self.driver.Date(2007, 05, 01)
        print datetime.date(2007, 05, 01)
        if self.driver_name == 'psycopg2':
            self.assertEqual(self.driver.Date(2007, 05, 01).adapted,  
                         datetime.date(2007, 05, 01))
        else:
            self.assertEqual(self.driver.Date(2007, 05, 01),
                         datetime.date(2007, 05, 01))

    def test_time(self):
        #TODO: Perhaps dropping str() makes it an intermediate test?
        #self.assertEqual(self.driver.Time(11, 03, 13), 
        #                 datetime.time(11, 03, 13))
        if self.driver_name == 'psycopg2':
            self.assertEqual(self.driver.Time(11, 03, 13).adapted, 
                         datetime.time(11, 03, 13))
        else:
            self.assertEqual(str(self.driver.Time(11, 03, 13)), 
                         str(datetime.time(11, 03, 13)))

    def test_timestamp(self):
        if self.driver_name == 'psycopg2':
            self.assertEqual(str(self.driver.Timestamp(2007, 05, 01, 11, 03, 13).adapted),
                        str(datetime.datetime(2007, 05, 01, 11, 03, 13)))
        else:
            self.assertEqual(self.driver.Timestamp(2007, 05, 01, 11, 03, 13),
                        datetime.datetime(2007, 05, 01, 11, 03, 13))

    #TODO: Put this back in
    #def test_binary(self):
    #    #TODO: Inserted str()s here for psycopg2
    #    self.assertEqual(str(self.driver.Binary(chr(0) + "'")),
    #                     str(buffer(chr(0) + "'")))

class TestConnection(AcuteBase):
    def test_success(self):
        """Successful connect and close"""
        self._connect()
        self.con.close()

    def test_close_commit(self):
        """Can't commit, execute, or close a closed connection """
        con = connect()
        con.close()
        self.assertRaises(self.driver.Error,con.commit)

    @requires('inoperable_closed_connections')
    def test_close_close(self):
        """Can't close a closed connection """
        con = connect()
        con.close()
        self.assertRaises(self.driver.Error,con.close)
        
    @requires('inoperable_closed_connections')
    def test_close(self):
        """Can't commit, execute, or close a closed connection """
        con, cs = connect_plus_cursor()
        con.close()

        qry = "select * from %sbooze" % table_prefix
        #Replacing this statement with the next to eliminate executeDDL
        #self.assertRaises(self.driver.Error,self.executeDDL1,cur)
        if self.driver_name == 'pysqlite2':
          self.assertRaises(self.driver.ProgrammingError,cs.execute(qry))
        elif self.driver_name == 'psycopg2':
          # Something about the way psycopg2 raises this screws up assertRaises.
          try:
              cs.execute(qry)
          except self.driver.InterfaceError:
              pass
          else:
              raise(AssertionError, 'Psycopg2 did not raise interfacerror')
          #self.assertRaises(self.driver.InterfaceError, cs.execute(qry))
        else:
          self.assertRaises(self.driver.Error,cs.execute(qry))

        self.assertRaises(self.driver.Error,con.commit)
        self.assertRaises(self.driver.Error,con.close)

    @requires('explicit_db_create')
    def test_bogusDB(self):
        """Connection should fail using bogus database"""
        connection_info = config.ConnectionInfo()
        connection_info.database = 'NonexistentDatabase'
        #TODO: Should this be more specific, like OperationalError?
        self.assertRaises(self.driver.Error, 
                          self._connect, connection_info)

    @requires('authentication')
    def test_bogusUser(self):
        """Connection should fail using bogus username"""
        connection_info = config.ConnectionInfo()
        connection_info.username = 'kingarthur'
        self.assertRaises(self.driver.Error,  
                          self._connect, connection_info)

    @requires('authentication')
    def test_bogusPwd(self):
        """Connection should fail using bogus password"""
        connection_info = config.ConnectionInfo()
        connection_info.password = 'xyzzy'
        self.assertRaises(self.driver.Error, 
                          self._connect, connection_info)

    @requires('authentication')
    def test_missingPwd(self):
        """Connection should fail using blank password"""
        connection_info = config.ConnectionInfo()
        connection_info.password = ''
        self.assertRaises(self.driver.Error, 
                          self._connect, connection_info)
     
    def test_commit_nochange(self):
        """Consecutive commits should be successfull"""
        self._connect()
        self.con.commit()
        self.con.commit()

    def test_rollback_nochange(self):
        """Consecutive rollbacks should be successfull"""
        self._connect()
        self.con.rollback()
        self.con.rollback()

    def test_cursor_create(self):
        """Connections need to be able to create cursors"""
        self._connect()
        self.failUnless(self.con.cursor(), "unable to create a cursor")

    @requires('connection_level_exceptions')
    def test_ExceptionsAsConnectionAttributes(self):
        """ Connection objects should include the exceptions as attributes (optional)"""
        con = self._connect()
        drv = self.driver
        self.failUnless(con.Warning is drv.Warning)
        self.failUnless(con.Error is drv.Error)
        self.failUnless(con.InterfaceError is drv.InterfaceError)
        self.failUnless(con.DatabaseError is drv.DatabaseError)
        self.failUnless(con.OperationalError is drv.OperationalError)
        self.failUnless(con.IntegrityError is drv.IntegrityError)
        self.failUnless(con.InternalError is drv.InternalError)
        self.failUnless(con.ProgrammingError is drv.ProgrammingError)
        self.failUnless(con.NotSupportedError is drv.NotSupportedError)

    def test_commit(self):
        """ Commit must be defined, even if it doesn't do anything """
        con = self._connect()
        try:
            con.commit()
        finally:
            con.close()

    @requires('rollback_defined')
    def test_rollback(self):
        """ Rollback must work or throw NotSupportedError."""
        #The spec allows drivers that don't support rollback to also 
        #simply not define this method, which is silly.  2 ways to do the same
        #trivial thing!
        #TODO: Suggest patch to PEP 249
        con = self._connect()
        if hasattr(con,'rollback'):
            try:
                con.rollback()
            except self.driver.NotSupportedError:
                pass

class TestCursor(AcuteBase):
    #TODO: Test lastrowid after bogus operations like ddl, or insert on table w/out rowid
    #TODO: Test not null violations
    def test_cursor(self):
        """ Connections must have cursor method """
        con = self._connect()
        try:
            cur = con.cursor()
        finally:
            con.close()
    
    @requires('lastrowid')
    #TODO: Does anything not support lastrowid?
    @requires('amiracle')
    def test_lastrowid(self):
        """ cursor.lastrowid should be set on insert with identity col. """
        con, cur = connect_plus_cursor()
        drop_table(con, cur, tables['booze'], ignore_errors=True)
        create_table(con, cur, ddl1)
        
        data = dict(name=None, desc='Bass')
        self._insert(con, cur, table=tables['booze'], data=data )
        self.failUnlessEqual(self.cs.lastrowid, 1)
        self.failUnlessEqual(self.cs.rowcount, 1)
        
    #TODO: Fix this test.
    @requires('amiracle')
    def test_insert_None(self):
        """ cs.execute() - INSERT (NULL)"""
        self._createTable()
        self._insertData( (None, None) )
        id_value = self.cs.lastrowid()
        self.assertEqual(1, id_value)

    #TODO: Fix this test
    @requires('amiracle')
    def test_insert_type_mismatch(self):
         """ cs.execute() - INSERT (Wrong type) """
         self._createTable()
         self.assertRaises(TypeError, self._insertData, (1.0, None))

    #TODO: Fix this test
    @requires('amiracle')
    def test_insert_truncation(self):
         """ cs.execute() - INSERT (Right truncation) """
         self._createTable()
         self.assertRaises(dbapi.ProgrammingError,
                           self._insertData, (1, 'XXXX'))

    #TODO: Fix this test.
    @requires('amiracle')
    def test_insert_parm_mismatch(self):
        """ cs.execute() - INSERT (Wrong # of params) """
        self._createTable()
        self.assertRaises(dbapi.ProgrammingError, self._insertData, (1, ))

    ##TODO: Fix this test
    ##@requires('callproc') #, 'amiracle')
    #def test_callproc_xxx(self):
    #    """cs.callproc() - IN, OUT, INOUT parameters"""
    #    con, cs = connect_plus_cursor()
    #    #TODO: Need to switch between CREATE PROCEDURE & CREATE FUNCTION as needed.
    #    cs.execute(
    #         """CREATE FUNCTION CP_TEST_1
    #         (IN P1 CHAR(5), OUT P2 VARCHAR(5), INOUT P3 INTEGER)
    #         LANGUAGE SQL
    #         BEGIN
    #              SET P2 = 'YYY';
    #              SET P3 = 3;
    #         END""")
    #    params = ( 'XXXXX', None, 1 )
    #    r = cs.callproc('CP_TEST_1', params)
    #    self.assertNotEqual( params, r )
    #    self.assertEqual( ('XXXXX', 'YYY', 3), r )
    #
    #@requires('amiracle')
    ##TODO: Fix this test
    #def test_callproc_xxx_resultsets(self):
    #    """cs.callproc() - w/ Result set"""
    #    con, cs = connect_plus_cursor()
    #    cs.execute("CREATE TABLE CP_TEST_TB ( P1 INTEGER )")
    #
    #    SIZE = 100;
    #    for i in range(SIZE):
    #        cs.execute("INSERT INTO CP_TEST_TB VALUES (%s)" % i)
    #
    #    if driver_supports.stored_procedure_language in ['SQL:2003', 'SQL/PL']:
    #        stmt = """CREATE FUNCTION CP_TEST_1
    #           (IN P1 INTEGER)
    #           LANGUAGE SQL
    #           BEGIN
    #              DECLARE CS1 CURSOR WITH RETURN FOR
    #                   SELECT * FROM CP_TEST_TB;
    #              OPEN CS1;
    #           END
    #           """
    #    elif driver_supports.stored_procedure_language in ['PL/pgSQL']:
    #        stmt = """CREATE FUNCTION populate() RETURNS integer AS $$
    #                DECLARE
    #                -- declarations
    #                BEGIN
    #                PERFORM my_function();
    #                END;
    #                $$ LANGUAGE plpgsql;
    #            """
    #    else:
    #        raise Unsupported
    #    cs.execute(stmt)
    #
    #    r = callproc("CP_TEST_1", 1)
    #    self.assertEqual(r, (1, ))
    #    rows = cs.fetchall()
    #    self.assertEqual(len(rows), SIZE)

    def test_arraysize(self):
        """ Cursor must define arraysize """
        con, cur = connect_plus_cursor()
        cur.arraysize

    #TODO: Flesh this out, break into 2.  First test that attribute defined, then test function
    def test_setinputsizes_basic(self):
        """ cursor.setinputsizes shouldn't blow up insert """
        con, cur = connect_plus_cursor()
        try:
            cur.setinputsizes( (25,) )
            self._insert(con, cur)
        finally:
            con.close()

    #TODO: Flesh this out, break into 2.  First test that attribute defined, then test function
    def test_setoutputsize_basic(self):
        """ cursor.setoutputsize shouldn't blow up insert """
        con, cur = connect_plus_cursor()
        try:
            cur.setoutputsize(1000)
            cur.setoutputsize(2000,0)
            self._insert(con, cur)
        finally:
            con.close()

    #TODO: Determine approaches used by the different drivers
    #def test_setoutputsize(self):
    #    # Real test for setoutputsize is driver dependant
    #    raise NotImplementedError,'Driver need to override this test'

    def test_cursor_isolation(self):
        """ Can read uncommitted data within a connection """
        #TODO: What about the converse?
        con = self._connect()
        try:
            cur1 = con.cursor()
            cur2 = con.cursor()
            #self.executeDDL1(cur1)
            cur1.execute("insert into %sbooze values ('Victoria Bitter')" % (
                table_prefix
                ))
            cur2.execute("select name from %sbooze" % table_prefix)
            booze = cur2.fetchall()
            self.assertEqual(len(booze),1)
            self.assertEqual(len(booze[0]),1)
            self.assertEqual(booze[0][0],'Victoria Bitter')
        finally:
            con.close()

    def test_description(self):
        """ Test cursor description """
        con, cur = connect_plus_cursor()
        drop_table(con, cur, tables['booze'], ignore_errors=True)
        drop_table(con, cur, tables['barflys'], ignore_errors=True)
        try:
            create_table(con, cur, ddl1)
            self.assertEqual(cur.description,None,
                "cursor.description should be none after executing a "
                "statement that can't return rows (such as DDL)"
                )
            cur.execute('select name from %sbooze' % table_prefix)
            self.assertEqual(len(cur.description),1,
                'cursor.description describes too many columns'
                )
            self.assertEqual(len(cur.description[0]),7,
                'cursor.description[x] tuples must have 7 elements'
                )
            self.assertEqual(cur.description[0][0].lower(),'name',
                'cursor.description[x][0] must return column name'
                )
            #TODO: Break this out into own test?
            if driver_name != 'pysqlite2':
                self.assertEqual(cur.description[0][1],self.driver.STRING,
                  'cursor.description[x][1] must return column type. Got %r'
                    % cur.description[0][1]
                  )

            create_table(con, cur, ddl2)
            self.assertEqual(cur.description,None,
                'cursor.description not being set to None when executing '
                'no-result statements (eg. DDL)'
                )
        finally:
            con.close()

    #TODO: Test rowcount with scrollable cursors?
    def test_rowcount(self):
        con, cur = connect_plus_cursor()
        drop_table(con, cur, tables['booze'], ignore_errors=True)
        drop_table(con, cur, tables['barflys'], ignore_errors=True)        
        try:
            create_table(con, cur, ddl1)
            #TODO: Check this against PEP 249.  Original code claimed -1 was correct answer
            self.assertEqual(cur.rowcount,0,
                'cursor.rowcount should be 0 after executing no-result '
                'statements, not %s' % cur.rowcount
                )
            cur.execute("insert into %sbooze values ('Victoria Bitter')" % (
                table_prefix
                ))
            self.failUnless(cur.rowcount in (-1,1),
                'cursor.rowcount should == number or rows inserted, or '
                'set to -1 after executing an insert statement'
                )
            cur.execute("select name from %sbooze" % table_prefix)
            #TODO: Move to own test.
            if driver_supports.sane_empty_fetch:
                self.failUnless(cur.rowcount in (-1,1),
                    'cursor.rowcount should == number of rows returned, or '
                    'set to -1 after executing a select statement, not %s.' % cur.rowcount
                    )
            create_table(con, cur, ddl2)
            #TODO: Check this against PEP 249.  Original code claimed -1 was correct answer
            self.assertEqual(cur.rowcount,0,
                'cursor.rowcount not being reset to 0 after executing '
                'no-result statements. It is %s' % cur.rowcount
                )
        finally:
            con.close()

    def test_rowcount_basic(self):
        #self.executeDDL1(cur)
        con, cur = connect_plus_cursor()
        cur.execute("insert into %sbooze values ('Victoria Bitter')" % (
            table_prefix
            ))
        self.failUnless(cur.rowcount in (-1,1))

    def test_insert(self):
        con, cur = connect_plus_cursor()
        self._insert(con, cur, data=dict(name="Cooper's"))
        self._insert(con, cur, data=dict(name="Victoria Bitter"))
        cur.execute('select name from %sbooze' % table_prefix)
        res = cur.fetchall()
        ls = len(res)
        self.assertEqual(ls, 2,'fetchall wrong number of rows: %s' % ls)
        beers = [res[0][0],res[1][0]]
        beers.sort()
        self.assertEqual(beers[0],"Cooper's",
            'cursor.fetchall retrieved incorrect data')
        self.assertEqual(beers[1],"Victoria Bitter",
            'cursor.fetchall retrieved incorrect data')

    @requires('scrollable_cursors', 'amiracle')
    def test_scrollable_basic(self):
        #TODO: Is this how we want scrollable cursors to behave?
        con, cur = connect_plus_cursor()
        cur.set_scrollable(True)
        cur.set_scrollable(False)
    
    @requires('scrollable_cursors', 'amiracle')
    def test_scrollable(self):
        #TODO: Is this how we want scrollable cursors to behave?  Fix test.
        con, cur = connect_plus_cursor()
        drop_table(con, cur, tables['booze'], ignore_errors=True)
        create_table(con, cur, ddl1)
        
        data = [ (1, 'a'), (2, 'bb'), (3, 'ccc') ]
        self.cs.executemany("INSERT INTO %s VALUES (?, ?)" % self.tableName, data)
        cur.set_scrollable(1)
        self.cs.execute("SELECT * FROM %s" % self.tableName)
        rows = self.cs.fetchmany( len(data) )
        for i in range( len(data) ):
            self.assertEqual(tuple(rows[i]),data[i])

    beer_samples = [
        'Carlton Cold',
        'Carlton Draft',
        'Mountain Goat',
        'Redback',
        'Victoria Bitter',
        'XXXX'
        ]

    def _populate(self, cur):
        """ Insert rows to setup the DB for the fetch tests. """
        # TODO: Switch name to create_and_populate, move to base?
        # drop_table(con, cur, tables['booze'], ignore_errors=True)
        # create_table(con, cur, ddl1)

        for s in self.beer_samples:
            cur.execute("insert into %sbooze values ('%s')" % (table_prefix,s))
        #commit?

    def test_executemany(self):
        con, cur = connect_plus_cursor()
        drop_table(con, cur, tables['booze'], ignore_errors=True)
        try:
            create_table(con, cur, ddl1)
            largs = [ ("Cooper's",) , ("Boag's",) ]
            margs = [ {'beer': "Cooper's"}, {'beer': "Boag's"} ]
            if self.driver.paramstyle == 'qmark':
                cur.executemany(
                    'insert into %sbooze values (?)' % table_prefix,
                    largs
                    )
            elif self.driver.paramstyle == 'numeric':
                cur.executemany(
                    'insert into %sbooze values (:1)' % table_prefix,
                    largs
                    )
            elif self.driver.paramstyle == 'named':
                cur.executemany(
                    'insert into %sbooze values (:beer)' % table_prefix,
                    margs
                    )
            elif self.driver.paramstyle == 'format':
                cur.executemany(
                    'insert into %sbooze values (%%s)' % table_prefix,
                    largs
                    )
            elif self.driver.paramstyle == 'pyformat':
                cur.executemany(
                    'insert into %sbooze values (%%(beer)s)' % (
                        table_prefix
                        ),
                    margs
                    )
            else:
                self.fail('Unknown paramstyle')
            #TODO: Move this to it's own test.  psycopg2 doesn't support
            #self.failUnless(cur.rowcount in (-1,2),
            #    'cursor.rowcount has incorrect value %r' % cur.rowcount
            #    )
            cur.execute('select name from %sbooze' % table_prefix)
            res = cur.fetchall()
            self.assertEqual(len(res),2,
                  'cursor.fetchall retrieved incorrect number of rows'
                  )  
            beers = [res[0][0],res[1][0]]
            beers.sort()
            self.assertEqual(beers[0],"Boag's",'incorrect data retrieved')            
            self.assertEqual(beers[1],"Cooper's",'incorrect data retrieved')
        finally:
            con.close()

    def test_fetchone(self):
        con, cur = connect_plus_cursor()
        drop_table(con, cur, tables['booze'], ignore_errors=True)
        create_table(con, cur, ddl1)

        try:
            cur.execute('select name from %sbooze' % table_prefix)
            self.assertEqual(cur.fetchone(),None,
                'cursor.fetchone should return None if a query retrieves '
                'no rows'
                )
            self.failUnless(cur.rowcount in (-1,0))

            cur.execute("insert into %sbooze values ('Victoria Bitter')" %
                        table_prefix)
            cur.execute('select name from %sbooze' % table_prefix)
            r = cur.fetchone()
            self.assertEqual(len(r),1,
                'cursor.fetchone should have retrieved a single row'
                )
            self.assertEqual(r[0],'Victoria Bitter',
                'cursor.fetchone retrieved incorrect data'
                )
            self.assertEqual(cur.fetchone(),None,
                'cursor.fetchone should return None if no more rows available'
                )
            #TODO: Move this into own test
            if driver_supports.rowcount_reset_empty_fetch:
                self.failUnless(cur.rowcount in (-1,0),
                                "rowcount should be reset after failed fetch")
        finally:
            con.close()

    def test_fetchmany(self):
        con, cur = connect_plus_cursor()
        drop_table(con, cur, tables['booze'], ignore_errors=True)
        drop_table(con, cur, tables['barflys'], ignore_errors=True)        

        create_table(con, cur, ddl1)
        try:
            self._populate(cur)
            cur.execute('select name from %sbooze' % table_prefix)
            r = cur.fetchmany()
            self.assertEqual(len(r),1,
                'cursor.fetchmany retrieved incorrect number of rows, '
                'default of arraysize is one.'
                )
            cur.arraysize=10
            r = cur.fetchmany(3) # Should get 3 rows
            self.assertEqual(len(r),3,
                'cursor.fetchmany retrieved incorrect number of rows'
                )
            r = cur.fetchmany(4) # Should get 2 more
            self.assertEqual(len(r),2,
                'cursor.fetchmany retrieved incorrect number of rows'
                )
            r = cur.fetchmany(4) # Should be an empty sequence
            self.assertEqual(len(r),0,
                'cursor.fetchmany should return an empty sequence after '
                'results are exhausted'
            )
            #TODO: Move this into it's own test
            if driver_supports.rowcount_reset_empty_fetch:
                self.failUnless(cur.rowcount in (-1,0),
                                "rowcount should be reset after empty fetch")

            # Same as above, using cursor.arraysize
            cur.arraysize=4
            cur.execute('select name from %sbooze' % table_prefix)
            r = cur.fetchmany() # Should get 4 rows
            self.assertEqual(len(r),4,
                'cursor.arraysize not being honoured by fetchmany'
                )
            r = cur.fetchmany() # Should get 2 more
            self.assertEqual(len(r),2)
            r = cur.fetchmany() # Should be an empty sequence
            self.assertEqual(len(r),0)
            if driver_supports.rowcount_reset_empty_fetch:
                self.failUnless(cur.rowcount in (-1,0),
                                "rowcount should be reset after empty fetch")

            cur.arraysize=6
            cur.execute('select name from %sbooze' % table_prefix)
            rows = cur.fetchmany() # Should get all rows
            if driver_supports.sane_rowcount:
              #TODO: Move this to own test.
              self.failUnless(cur.rowcount in (-1,6))
            self.assertEqual(len(rows),6)
            self.assertEqual(len(rows),6)
            rows = [r[0] for r in rows]
            rows.sort()

            # Make sure we get the right data back out
            for i in range(0,6):
                self.assertEqual(rows[i],self.beer_samples[i],
                    'incorrect data retrieved by cursor.fetchmany'
                    )

            rows = cur.fetchmany() # Should return an empty list
            self.assertEqual(len(rows),0,
                'cursor.fetchmany should return an empty sequence if '
                'called after the whole result set has been fetched'
                )
            if driver_supports.rowcount_reset_empty_fetch:
                self.failUnless(cur.rowcount in (-1,0),
                                "rowcount should be reset after empty fetch")

            create_table(con, cur, ddl2)
            cur.execute('select name from %sbarflys' % table_prefix)
            r = cur.fetchmany() # Should get empty sequence
            self.assertEqual(len(r),0,
                'cursor.fetchmany should return an empty sequence if '
                'query retrieved no rows'
                )
            self.failUnless(cur.rowcount in (-1,0),
                            "rowcount should be reset after empty fetch")

        finally:
            con.close()

    def test_fetchall(self):
        con, cur = connect_plus_cursor()
        drop_table(con, cur, tables['booze'], ignore_errors=True)
        create_table(con, cur, ddl1)

        try:
            self._populate(cur)
            cur.execute('select name from %sbooze' % table_prefix)
            rows = cur.fetchall()
            self.assertEqual(len(rows),len(self.beer_samples),
                'cursor.fetchall did not retrieve all rows'
                )
            if driver_supports.sane_rowcount:
              #TODO: Move to own test.  BTW, is sane_rowcount really sane_fetchall_rowcount?
              self.failUnless(cur.rowcount in (-1,len(self.beer_samples)))
            rows = [r[0] for r in rows]
            rows.sort()
            for i in range(0,len(self.beer_samples)):
                self.assertEqual(rows[i],self.beer_samples[i],
                'cursor.fetchall retrieved incorrect rows'
                )
            rows = cur.fetchall()
            self.assertEqual(
                len(rows),0,
                'cursor.fetchall should return an empty list if called '
                'after the whole result set has been fetched'
                )
            if driver_supports.sane_rowcount:
              self.failUnless(cur.rowcount in (-1,len(self.beer_samples)))

            #self.executeDDL2(cur)
            cur.execute('select name from %sbarflys' % table_prefix)
            rows = cur.fetchall()
            self.failUnless(cur.rowcount in (-1,0))
            self.assertEqual(len(rows),0,
                'cursor.fetchall should return an empty list if '
                'a select query returns no rows'
                )
        finally:
            con.close()

    @requires('sane_empty_fetch')
    def test_emptyfetch(self):
        """ Fetch methods should raise Error if no query issued """
        con, cur = connect_plus_cursor()
        self.assertRaises(self.driver.Error,cur.fetchone)
        self.assertRaises(self.driver.Error,cur.fetchmany,4)
        self.assertRaises(self.driver.Error, cur.fetchall)

        """ Fetch should still fail after executing queries that can't
        return rows.
        """
        # Create table
        drop_table(con, cur, tables['booze'], ignore_errors=True)
        create_table(con, cur, ddl1)
        self.assertRaises(self.driver.Error,cur.fetchone)
        self.assertRaises(self.driver.Error,cur.fetchmany,4)
        self.assertRaises(self.driver.Error,cur.fetchall)
  
        # Insert
        cur.execute("insert into %sbooze values ('Victoria Bitter')" % (
            table_prefix
            ))
        self.assertRaises(self.driver.Error,cur.fetchone)

    def test_mixedfetch(self):
        con, cur = connect_plus_cursor()
        drop_table(con, cur, tables['booze'], ignore_errors=True)
        create_table(con, cur, ddl1)

        try:
            self._populate(cur)
            cur.execute('select name from %sbooze' % table_prefix)
            rows1  = cur.fetchone()
            rows23 = cur.fetchmany(2)
            rows4  = cur.fetchone()
            rows56 = cur.fetchall()
            if driver_supports.sane_rowcount:
              self.failUnless(cur.rowcount in (-1,6))
            self.assertEqual(len(rows23),2,
                'fetchmany returned incorrect number of rows'
                )
            self.assertEqual(len(rows56),2,
                'fetchall returned incorrect number of rows'
                )

            rows = [rows1[0]]
            rows.extend([rows23[0][0],rows23[1][0]])
            rows.append(rows4[0])
            rows.extend([rows56[0][0],rows56[1][0]])
            rows.sort()
            for i in range(0,len(self.beer_samples)):
                self.assertEqual(rows[i],self.beer_samples[i],
                    'incorrect data retrieved or inserted'
                    )
        finally:
            con.close()

    #TODO: Put this in alien_tech
    #@requires('drop_schema')
    #def test_drop_schema(self):
        #cs = db.cursor()
        #cs.dropschema(object_type="all")
        #db.commit()
        
    #TODO: Put this in alien_tech
    #@requires('blobs', 'lob_file_handler')
    #def test_lob_open(self):
        #from psycopg2 import *
        #dsn = 'host=%s dbname=%s user=%s password=%s' % (
        #       'localhost', 'kskuhlman', 'kskuhlman', 'itsasecret')
        #
        ##blob_type = 'blob'
        #blob_type = 'text'
        #
        ##con = connect('blob_test')
        #con = connect(dsn=dsn)
        #cur = con.cursor()
        #try:
        #    #cur.execute('drop table text_table')
        #    pass
        #except: 
        #    try: 
        #        cur.rollback()
        #    except: 
        #        pass
        #
        #print "Paramstyle", paramstyle
        #cur.execute('create table text_table (mylob %s)' % blob_type)
        #
        #src = open('test_dbapi.py')
        #
        #cur.execute('insert into text_table values(?)', [src.read(),])
        ##SQLite
        ##cur.execute('insert into text_table values(?)', [Binary(src.read()),])
        ##cur.execute('insert into text_table values(?)', [Binary(src),])
        #
        ##Postgres
        #cur.execute('insert into text_table values(%(val)s)', dict(val=Binary(src.read())))
        #print "read() insert successful"
        #cur.execute('insert into text_table values(%(val)s)', dict(val=Binary(src)))
        #print "no read() insert successful"
        #cur.execute('insert into text_table values(mylob = ?)', src)
        #print "no Binary insert successful"

    tableName = "%sblobtst" % table_prefix
    
    def _createBLOBTable(self, con, cs):
        try:
          cs.execute("drop table %s" % self.tableName)
        except:
          con.rollback()
        #cs.execute("CREATE TABLE %s ( P1 BLOB(1024), P2 BLOB(1024) )"
        #                % self.tableName)
        bt = driver_supports.blob_type
        cs.execute("CREATE TABLE %s ( P1 %s, P2 %s )" % (self.tableName, bt, bt))

    @requires('smart_lob_open')
    def test_blob_smart_open(self):
        """BLOB (file)"""
        con, cs = connect_plus_cursor()
        import os
        self._createBLOBTable(con, cs)
        f = os.tmpfile()
        data = '\xae' * 1024
        f.write(data)
        f.seek(0, 0)
        #print "Paramstyle is: %s" % self.driver.paramstyle
        cs.execute("INSERT INTO %s (P1) VALUES (?)" % self.tableName, f)
        cs.execute("SELECT * FROM %s" % self.tableName)
        rows = cs.fetchone()
        self.assertEqual(str(rows[0]), data)

    #TODO: Fix test to work with more than just pyformat.
    @requires('blob_binary')
    def test_BLOB_fetchmany(self):
        con, cs = connect_plus_cursor()
        SIZE = 10
        self._createBLOBTable(con, cs)
        for i in range(SIZE):
            data = dict(P1=self.driver.Binary(chr(i) * i),
                        P2=self.driver.Binary(chr(i) * (1024-i)), )
            ps = self.driver.paramstyle
            if ps == 'qmark':
                cs.execute("INSERT INTO %s VALUES (?, ?)" % self.tableName, data.values)
            elif ps == 'numeric':
                cs.execute("INSERT INTO %s VALUES (:1, :2)" % self.tableName, data.values)
            elif self.driver.paramstyle == 'named':
                cs.execute("INSERT INTO %s VALUES (:%s, :%s)" % self.tableName, data)
            elif ps == 'format':
                cs.execute("INSERT INTO %s VALUES (%s, %s)" % self.tableName, data)
            elif ps == 'pyformat':
                cs.execute("INSERT INTO %s VALUES ((%%(P1)s), (%%(P2)s))" %
                       self.tableName, data)
        cs.execute("SELECT * FROM %s" % self.tableName)
        rows = cs.fetchmany(SIZE)


class TestTypesEmbedded(AcuteBase):
    def setUp(self):
        self.con, self.cs = connect_plus_cursor()
        self.table = tables['testtypes']
        drop_table(self.con, self.cs, self.table, ignore_errors=True)
        create_table(self.con, self.cs, ddl3)

    def tearDown(self):
        self.con.rollback()
        drop_table(self.con, self.cs, self.table, ignore_errors=True)
        self.con.close()

    def _get_lastrow(self):
        """Return the last row inserted by this process"""
        id_value = self.cs.lastrowid
        self._insert(self.con, self.cs, table=self.table, data=dict(int1=id_value), stmt_type='select')
        #TODO: Was the ugly hack to insert worth it?  Or should I just not use parammarker here?
        #self.cs.execute('select * from %s where int1 = ?' % self.table, id_value)
        row = self.cs.fetchone()
        return row

    def _get_row(self, table):
        """ Return a row from a table.  If there's more than one row, it's an error """
        self.cs.execute("select * from %s" % table)
        row = self.cs.fetchall()
        cnt = len(row)
        self.assertEqual(cnt, 1, "Invalid row count %s from fetchall" % cnt)
        return row[0]

    def test_date_insert_string(self):
        date1 = '2007-05-01'
        #date1 = "'05/01/2007'"
        data = dict(date1 = datetime.date(2007, 05, 01))
        self._insert(self.con, self.cs, table=self.table, data=data)
        #TODO: Weakened this test to str() for psycopg2
        self.assertEqual(str(self._get_row(self.table)[2]), date1)

    def test_date_insert(self):
        date1_string = '2007-05-01'
        date1 = datetime.date(2007, 05, 01)
        data = dict(date1 = date1)
        self._insert(self.con, self.cs, table=self.table, data=data)
        self.assertEqual(str(self._get_row(self.table)[2]), date1_string)

    def test_timestamp_insert_string(self):
        timestamp1 = '2007-05-01 16:00:57.180210'
        timestamp1_datetime = datetime.datetime(2007, 05, 01, 16, 00, 57, 180210)
        self._insert(self.con, self.cs, table=self.table, data=dict(timestamp1=timestamp1))
        #print "RowID is ", self.cs.lastrowid, "."
        self.assertEqual(str(self._get_row(self.table)[3]),timestamp1)
        #self.assertEqual(self._get_lastrow()[3],timestamp1_datetime)

    def test_timestamp_insert(self):
        timestamp1 = datetime.datetime(2007, 05, 01, 11, 03, 13)
        timestamp1_string = '2007-05-01 11:03:13'
        self._insert(self.con, self.cs, table=self.table, data=dict(timestamp1=timestamp1))
        self.assertEqual(str(self._get_row(self.table)[3]),timestamp1_string)
        #self.assertEqual(self._get_lastrow()[3],timestamp1)

    @requires('time_datatype')
    def test_time_insert_string(self):
        time1 = '11:03:13'
        time1_time = datetime.time(11, 03, 13)
        self._insert(self.con, self.cs, table=self.table, data=dict(time1=time1))
        #self.assertEqual(self._get_lastrow()[4],time1_time)
        self.assertEqual(str(self._get_row(self.table)[4]),time1)

    @requires('time_datatype_time')
    def test_time_insert(self):
        data = dict(time1 = datetime.time(11, 3, 13))
        self._insert(self.con, self.cs, table=self.table, data=data)
        self.assertEqual(self._get_row(self.table)[4],data['time1'])

    @requires('time_datatype_subsecond')
    def test_time_insert_subsecond_string(self):
        time1 = '11:03:13.9999'
        data = dict(time1 = time1)
        self._insert(self.con, self.cs, table=self.table, data=data)

    @requires('time_datatype_subsecond', 'time_datatype_time')
    def test_time_insert_subsecond(self):
        data = dict(time1 = datetime.time(11, 3, 13, 9999))
        self._insert(self.con, self.cs, table=self.table, data=data)

    @requires('time_datatype_time')
    def test_datatypes_multi(self):
        data = dict(date1=datetime.date(1970, 4, 1),
                    timestamp1=datetime.datetime(2005, 11, 10, 11, 52, 35, 54839),
                    time1=datetime.time(23, 59, 59))
        self._insert(self.con, self.cs, table=self.table, data=data)
        
    @requires('time_datatype')
    def test_datatypes_multi_string(self):
        data = dict(date1='1970-04-01',
                    timestamp1='2007-05-01 11:03:13',
                    time1='11:03:13')
        self._insert(self.con, self.cs, table=self.table, data=data)
        
    def test_None(self):
        con, cur = connect_plus_cursor()
        drop_table(con, cur, tables['booze'], ignore_errors=True)
        create_table(con, cur, ddl1)
        try:
            cur.execute('insert into %sbooze values (NULL)' % table_prefix)
            cur.execute('select name from %sbooze' % table_prefix)
            r = cur.fetchall()
            self.assertEqual(len(r),1)
            self.assertEqual(len(r[0]),1)
            self.assertEqual(r[0][0],None,'NULL value not returned as None')
        finally:
            con.close()

class TestSQLProcs(AcuteBase):

    @requires('callproc', 'lower_func')
    @requires('amiracle')
    def test_callproc(self):
        con = self._connect()
        try:
            cur = con.cursor()
            r = cur.callproc(driver_supports.lower_func,('FOO',))
            self.assertNotEqual(r, None)
            self.assertEqual(len(r),1)
            self.assertEqual(r[0],'FOO')
            r = cur.fetchall()
            self.assertNotEqual(r, None, 'callproc produced no result set')
            self.assertEqual(len(r),1,'callproc produced no result set')
            self.assertEqual(len(r[0]),1,
                'callproc produced invalid result set'
                )
            self.assertEqual(r[0][0],'foo',
                'callproc produced invalid results'
                )
        finally:
            con.close()

    def help_nextset_setUp(self,cur):
        ''' Create a procedure called deleteme that returns two result sets,
        first the number of rows in booze then "name from booze"
        '''
        raise NotImplementedError,'Helper not implemented'
        #TODO: Implement this.
        #sql="""
        #    create procedure deleteme as
        #    begin
        #        select count(*) from booze
        #        select name from booze
        #    end
        #"""
        #cur.execute(sql)

    def help_nextset_tearDown(self,cur):
        'If cleaning up is needed after nextSetTest'
        raise NotImplementedError,'Helper not implemented'
        #TODO: Implement this.
        #cur.execute("drop procedure deleteme")

    @requires('callproc', 'nextset')
    def test_nextset(self):
        con, cur = connect_plus_cursor()
        drop_table(con, cur, tables['booze'], ignore_errors=True)
        create_table(con, cur, ddl1)
        self._populate(cur)

        try:
            self.help_nextset_setUp(cur)
            cur.callproc('deleteme')
            numberofrows=cur.fetchone()
            assert numberofrows[0]== len(self.beer_samples)
            assert cur.nextset()
            names=cur.fetchall()
            assert len(names) == len(self.beer_samples)
            s=cur.nextset()
            assert s == None,'No more return sets, should return None'
        finally:
            self.help_nextset_tearDown(cur)
            con.close()

    def test_nextset(self):
        #TODO: raise NotImplementedError,'Drivers need to override this test'
        pass

setup_once()
if __name__ == '__main__':
    setup_once()
    suite = unittest.TestSuite()

    for test in [
        TestModule,
        TestModuleDatatypes,
        TestConnection, 
        TestCursor,
        TestTypesEmbedded,
        TestSQLProcs,
        ]:
        suite.addTest(unittest.makeSuite(test))

    unittest.TextTestRunner(verbosity=2).run(suite)

